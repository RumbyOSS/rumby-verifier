'use client';

import { HistoryTable } from "@/components/app/provably_fair/HistoryTable";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import axios from '@/services/axios';
import { History } from "../types";

const DATA_PER_PAGE = 10;
const Page = () => {
    const [histories, setHistories] = useState<History[]>([]);
    const [count, setCount] = useState(0);
    const [page, setPage] = useState(0);
    const [isLoading, setIsLoading] = useState(false);
    const hasInit = useRef(false);

    const maxPage = useMemo(() => {
        return Math.floor(count / DATA_PER_PAGE);
    }, [count]);

    const getData = useCallback(async(page = 0) => {
        if(isLoading) return;
        try {
            setIsLoading(true);
            const res = await axios.get<History[]>(`/roulette/page/${page}`);
            setHistories(res.data);
        }

        catch {
            // do nothing
        }
        setIsLoading(false);
    }, [isLoading]);

    const onLeftClick = useCallback(() => {
        if(isLoading) return;
        const newPage = page - 1;
        if(newPage < 0) {
            return;
        }

        setPage(newPage);
        getData(newPage);
    }, [isLoading, page, getData]);

    const onRightClick = useCallback(() => {
        if(isLoading) return;
        const newPage = page + 1;
        if(newPage > maxPage) {
            return;
        }

        setPage(newPage);
        getData(newPage);
    }, [isLoading, page, maxPage, getData]);

    const getCount = useCallback(async() => {
        try {
            const res = await axios.get<string>("/roulette/count");
            setCount(Number(res.data));
        }

        catch {
            // do nothing
        }
    }, []);

    useEffect(() => {
        if(hasInit.current) return;
        hasInit.current = true;
        getData();
        getCount();
    }, [getData, getCount]);

	return (
		<div className="flex flex-col w-full">
			
			<div className="flex flex-col text-white">
                <strong>Roulette Details</strong>
                <span className="mt-[10px]">{`All Rumby games are fair and transparent, with every detail recorded and executed through a smart contract. Because these details exist on-chain, their fairness can be easily verified.`}</span>
                <span className="mt-[10px]">{`Here's how Rumby Roulette works:`}</span>
                <ul style={{ listStyle: "decimal" }} className="[&>*]:ml-[30px] mt-[10px] space-y-[20px]">
                    <li>
                        {`Each game round is created on-chain, where the keccak256-hashed server seed is stored its account state to prevent any future tampering. This hashed server seed is disclosed to all participants and can be independently verified once the unhashed server seed is revealed upon the round's conclusion.`}
                    </li>
                    <li>{`When placing a bet, the player has to choose between 4 options, namely Green, Yellow, Blue, and Pattern, where Green = 0, Yellow = 1, Blue = 2, Pattern = 3 when on chain.`}
                    </li>
                    <li>
                        {`To win, the bet's choice must fulfill these conditions:`}
                        <ul style={{ listStyle: "disc", marginLeft: 20 }}>
                            <li>Green: The outcome must be 0.</li>
                            <li>Yellow: The outcome must be 1, 3, 5, 7, 9, 11, or 13.</li>
                            <li>Blue: The outcome must be 2, 4, 6, 8, 10, 12, or 14.</li>
                            <li>Green: The outcome must be 7 or 14.</li>
                        </ul>
                    </li>
                    <li>{`Each bet is independent of each other, meaning that players are allowed to have multiple bets with different choices.`}</li>
                    <li>
                        {`Once a player joins a round, a timer is initiated. When the timer expires, the game state is locked on-chain, preventing any additional players from joining.`}
                    </li>
                    <li>
                        {`The house option is then made available to bet, which is fulfilled by house players.`}
                    </li>
                    <li>
                        {`Once the house bet matches the total amount of player bets, a public seed is determined by retrieving the block hash of a future Solana block, which acts as a random value that is both unpredictable and immutable, thereby ensuring fairness.`}
                    </li>
                    <li>
                        {`A random number is then generated by using the following code:`}
                        <div className="p-[10px] bg-white/10 rounded">
                        <code className="whitespace-pre font-ibm text-[12px]">
                            {`const getRandomNumberFromSeeds = (serverSeed: Buffer, publicSeed: Buffer, odds: bigint) => {
    if (serverSeed.length !== 32 || publicSeed.length !== 32) {
        throw new Error('Both serverSeed and publicSeed must be 32 bytes long.');
    }

    const combinedSeed = Buffer.concat([Uint8Array.from(serverSeed), Uint8Array.from(publicSeed)]); // 64 bytes

    // keccak256 hash the combined seed
    const hashResult = keccak256(combinedSeed); // 32 bytes

    const upper = BigInt('0x' + hashResult.slice(0, 16).toString('hex'));
    const lower = BigInt('0x' + hashResult.slice(16, 32).toString('hex'));

    const finalHash = upper ^ lower;

    let result: bigint = BigInt(0);
    if (odds > BigInt(0)) {
        result = (finalHash % odds) + BigInt(1);
    }

    return result;
}`}
                            </code>
                        </div>
                    </li>
                    <li>
                        {`Where the outcome is determined by using the following code:`}
                        <div className="p-[10px] bg-white/10 rounded">
                        <code className="whitespace-pre font-ibm text-[12px]">
                            {`const resolveRouletteOutcome = (randomNumber: number): RouletteOutcome => {
    const outcomeIndex = randomNumber % 15;

    const outcomes: RouletteOutcome[] = [
        RouletteOutcome.Jackpot,    // 0
        RouletteOutcome.Yellow,     // 1
        RouletteOutcome.Blue,       // 2
        RouletteOutcome.Yellow3,    // 3
        RouletteOutcome.Blue4,      // 4
        RouletteOutcome.Yellow5,    // 5
        RouletteOutcome.Blue6,      // 6
        RouletteOutcome.Yellow7,    // 7 (Yellow Pattern)
        RouletteOutcome.Blue8,      // 8
        RouletteOutcome.Yellow9,    // 9
        RouletteOutcome.Blue10,     // 10
        RouletteOutcome.Yellow11,   // 11
        RouletteOutcome.Blue12,     // 12
        RouletteOutcome.Yellow13,   // 13
        RouletteOutcome.Blue14,     // 14 (Blue Pattern)
    ];

    return outcomes[outcomeIndex];
}`}
                            </code>
                        </div>
                    </li>
                    <li>
                        {`The unhashed server seed is subsequently published on-chain.`}
                    </li>
                    <li>
                        {`The bets that fulfill the condition to win are awarded their winnings. The remainder is awarded to the house players. Due to transaction size limitations, the winnings are oftentimes sent over a few transactions.`}
                    </li>
                </ul>
            </div>
            <div 
                className="h-[1px] w-full self-center my-[50px]"
                style={{
                    background: "linear-gradient(90deg, rgba(96, 59, 247, 0) 0.95%, #603BF7 53.37%, rgba(57, 34, 145, 0) 99.35%)"
                }}    
            >

            </div>
			<HistoryTable
				title="Roulette History"
                histories={histories}
                onLeftClick={onLeftClick}
                onRightClick={onRightClick}
                page={page}
                maxPage={maxPage}
			/>
		</div>
	)
};

export default Page;
