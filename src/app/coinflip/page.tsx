'use client';

import { HistoryTable } from "@/components/app/provably_fair/HistoryTable";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import axios from '@/services/axios';
import { History } from "../types";
import { LAMPORTS_PER_SOL } from "@solana/web3.js";

const DATA_PER_PAGE = 10;
const Page = () => {
    const [histories, setHistories] = useState<History[]>([]);
    const [count, setCount] = useState(0);
    const [page, setPage] = useState(0);
    const [isLoading, setIsLoading] = useState(false);
    const hasInit = useRef(false);

    const maxPage = useMemo(() => {
        return Math.floor(count / DATA_PER_PAGE);
    }, [count]);

    const getData = useCallback(async(page = 0) => {
        if(isLoading) return;
        try {
            setIsLoading(true);
            const res = await axios.get<History[]>(`/coinflip/page/${page}`);
            setHistories(res.data);
        }

        catch {
            // do nothing
        }
        setIsLoading(false);
    }, [isLoading]);

    const onLeftClick = useCallback(() => {
        if(isLoading) return;
        const newPage = page - 1;
        if(newPage < 0) {
            return;
        }

        setPage(newPage);
        getData(newPage);
    }, [isLoading, page, getData]);

    const onRightClick = useCallback(() => {
        if(isLoading) return;
        const newPage = page + 1;
        if(newPage > maxPage) {
            return;
        }

        setPage(newPage);
        getData(newPage);
    }, [isLoading, page, maxPage, getData]);

    const getCount = useCallback(async() => {
        try {
            const res = await axios.get<string>("/coinflip/count");
            setCount(Number(res.data));
        }

        catch {
            // do nothing
        }
    }, []);

    useEffect(() => {
        if(hasInit.current) return;
        hasInit.current = true;
        getData();
        getCount();
    }, [getData, getCount]);

	return (
		<div className="flex flex-col w-full">
			<div className="flex flex-col text-white">
                <strong>Coinflip Details</strong>
                <span className="mt-[10px]">{`All Rumby games are fair and transparent, with every detail recorded and executed through a smart contract. Because these details exist on-chain, their fairness can be easily verified.`}</span>
                <span className="mt-[10px]">{`Here's how Rumby Coinflip works:`}</span>
                <ul style={{ listStyle: "decimal" }} className="[&>*]:ml-[30px] mt-[10px] space-y-[20px]">
                    <li>
                        {`Each game round is created on-chain, where the keccak256-hashed server seed is stored its account state to prevent any future tampering. This hashed server seed is disclosed to all participants and can be independently verified once the unhashed server seed is revealed upon the round's conclusion.`}
                    </li>
                    <li>{`Each bet is assigned a range of tickets with unique IDs, with 1 lamport corresponding to 1 ticket. For example, if a player placed a 1 SOL bet, they will receive ${LAMPORTS_PER_SOL} tickets for that round.`}</li>
                    <li>
                        {`A player enters a round by placing an initial bet and selecting either heads or tails. The opponent must then match the bet amount and can only choose the opposite option.`}
                    </li>
                    <li>
                        {`Once two players join a round, the game state is locked on-chain. A public seed is then determined by retrieving the block hash of a future Solana block, which acts as a random value that is both unpredictable and immutable, thereby ensuring fairness.`}
                    </li>
                    <li>
                        {`A random number is then generated by using the following code:`}
                        <div className="p-[10px] bg-white/10 rounded">
                        <code className="whitespace-pre font-ibm text-[12px]">
                            {`const getRandomNumberFromSeeds = (serverSeed: Buffer, publicSeed: Buffer, odds: bigint) => {
    if (serverSeed.length !== 32 || publicSeed.length !== 32) {
        throw new Error('Both serverSeed and publicSeed must be 32 bytes long.');
    }

    const combinedSeed = Buffer.concat([Uint8Array.from(serverSeed), Uint8Array.from(publicSeed)]); // 64 bytes

    // keccak256 hash the combined seed
    const hashResult = keccak256(combinedSeed); // 32 bytes

    const upper = BigInt('0x' + hashResult.slice(0, 16).toString('hex'));
    const lower = BigInt('0x' + hashResult.slice(16, 32).toString('hex'));

    const finalHash = upper ^ lower;

    let result: bigint = BigInt(0);
    if (odds > BigInt(0)) {
        result = (finalHash % odds) + BigInt(1);
    }

    return result;
}`}
                            </code>
                        </div>
                    </li>
                    <li>
                        {`The winnings is awarded to the player whose ticket ID matches the randomly generated number.`}
                    </li>
                    <li>
                        {`The unhashed server seed is subsequently published on-chain together with the payout distribution.`}
                    </li>
                </ul>
            </div>
            <div 
                className="h-[1px] w-full self-center my-[50px]"
                style={{
                    background: "linear-gradient(90deg, rgba(96, 59, 247, 0) 0.95%, #603BF7 53.37%, rgba(57, 34, 145, 0) 99.35%)"
                }}    
            >

            </div>
			<HistoryTable
				title="Coinflip History"
                histories={histories}
                onLeftClick={onLeftClick}
                onRightClick={onRightClick}
                page={page}
                maxPage={maxPage}
			/>
		</div>
	)
};

export default Page;
